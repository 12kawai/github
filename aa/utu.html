<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>インベーダーゲーム</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #222;
      background-image: url("back.jpg");
      background-size: cover;
    }
    canvas {
      border: 1px solid #ffffff;
    }
    
  </style>
</head>

<body>
  
  <canvas id="gameCanvas" width="700" height="500"></canvas>
  <div style="position: absolute; bottom: 10px; color: white; font-size: 24px; font-weight: bold; text-align: center; width: 100%;">    操作説明: 左移動 (A) 右移動 (D) 射撃 (W)
  </div>

  <a href="index.php" style="position: absolute; top: 10px; left: 10px; color: white; text-decoration: none;">タイトルへ</a>
  <!-- ゲームの再起動ボタンを追加 -->
  <button onclick="restartGame()" style="position: absolute; top: 10px; right: 10px;">start</button>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const keys = {};


    document.addEventListener('keydown', (e) => {
  keys[e.code] = true;

  // スペースキーが押されたときに弾を発射
  if (e.code === 'KeyW') {
    player.bullets.push({
      x: player.x + player.size / 2 - 2,
      y: player.y - 10,
      size: 4,
      speed: 6
    });
  }

  // Aキーが押されたときに左へ移動
  if (e.code === 'KeyA') {
    keys['ArrowLeft'] = true;
  }

  // Dキーが押されたときに右へ移動
  if (e.code === 'KeyD') {
    keys['ArrowRight'] = true;
  }
});

document.addEventListener('keyup', (e) => {
  keys[e.code] = false;

  // Aキーが離されたときに左への移動を停止
  if (e.code === 'KeyA') {
    keys['ArrowLeft'] = false;
  }

  // Dキーが離されたときに右への移動を停止
  if (e.code === 'KeyD') {
    keys['ArrowRight'] = false;
  }
});
    let player = {
      x: canvas.width / 2,
      y: canvas.height - 30 - 30, // 上に30px移動
      size: 60,
      speed: 4,
      bullets: [],
      ready: false
    };

    let enemies = [];
    let enemySpawnCounter = 0;
    let moveDirection = 1;
    let moveDownCounter = 0;
    let score = 0;

    let playerImage = new Image();
    playerImage.src = "jibun.png";
    playerImage.onload = function() {
      player.image = playerImage;
      player.ready = true;
    };

    let enemyImage = new Image();
    enemyImage.src = "teki.png";
    enemyImage.onload = function() {
      for (const enemy of enemies) {
        enemy.image = enemyImage;
        enemy.ready = true;
      }
    };

    function drawEnemies() {
      for (const enemy of enemies) {
        if (enemy.ready) {
          ctx.drawImage(enemy.image, enemy.x, enemy.y, enemy.size, enemy.size);
        }
      }
    }

    function drawBullets() {
      ctx.fillStyle = 'yellow';
      for (const bullet of player.bullets) {
        ctx.fillRect(bullet.x, bullet.y, bullet.size, bullet.size);
      }
    }
        // 画面外に行ったら反対に出てくるように位置を調整する関数
function wrapAround(entity) {
  if (entity.x > canvas.width) {
    entity.x = -entity.size;
  } else if (entity.x + entity.size < 0) {
    entity.x = canvas.width;
  }
}

// ゲームオーバーの状態を管理する変数を追加
let gameOver = false;

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!gameOver) {
    // ゲームオーバーでない場合にゲームを更新

    if (player.ready) {
      ctx.drawImage(player.image, player.x, player.y, player.size, player.size);
    }

    drawEnemies();
    drawBullets();

    if (keys['ArrowLeft']) {
      player.x -= player.speed;
    }
    if (keys['ArrowRight']) {
      player.x += player.speed;
    }

    for (const bullet of player.bullets) {
      bullet.y -= bullet.speed;
    }
    player.bullets = player.bullets.filter(bullet => bullet.y > 0);

    // 弾と敵の衝突判定を追加
    player.bullets.forEach((bullet) => {
      enemies.forEach((enemy) => {
        if (
          bullet.x < enemy.x + enemy.size &&
          bullet.x + bullet.size > enemy.x &&
          bullet.y < enemy.y + enemy.size &&
          bullet.y + bullet.size > enemy.y
        ) {
          bullet.toRemove = true;
          enemy.toRemove = true;
          score += 10;
        }
      });
    });

    player.bullets = player.bullets.filter((bullet) => !bullet.toRemove);
    enemies = enemies.filter((enemy) => !enemy.toRemove);

    enemySpawnCounter++;
    if (enemySpawnCounter >= 30) {
      let newEnemy = {
        x: Math.random() * (canvas.width - 20),
        y: 10,
        size: 40,
        speed: 2,
        ready: false
      };
      newEnemy.image = enemyImage;
      newEnemy.ready = true;
      enemies.push(newEnemy);
      enemySpawnCounter = 0;
    }

    moveDownCounter++;
    if (moveDownCounter >= 60) {
      moveDirection = -moveDirection;
      for (const enemy of enemies) {
        enemy.y += 20;
      }
      moveDownCounter = 0;
    }

    for (const enemy of enemies) {
      enemy.x += enemy.speed * moveDirection;
    }
    enemies = enemies.filter(enemy => enemy.y < canvas.height);

    ctx.fillStyle = "white";
    ctx.font = "16px Arial";
    ctx.fillText("Score: " + score, 10, 20);

    // プレイヤーの位置を調整
  player.x = (player.x + canvas.width) % canvas.width;

// 敵の位置を調整
for (const enemy of enemies) {
  enemy.x = (enemy.x + canvas.width) % canvas.width;
}

    // プレイヤーと敵の当たり判定をチェック
    for (const enemy of enemies) {
      if (
        player.x < enemy.x + enemy.size &&
        player.x + player.size > enemy.x &&
        player.y < enemy.y + enemy.size &&
        player.y + player.size > enemy.y
      ) {
        // プレイヤーが敵に当たった場合、ゲームオーバーにする
        gameOver = true;
      }
    }

    requestAnimationFrame(update);
  } else {
    // ゲームオーバー画面を表示
    ctx.fillStyle = "white";
    ctx.font = "40px Arial";
    ctx.fillText("Game Over", canvas.width / 2 - 100, canvas.height / 2);
// 最終スコアを表示
ctx.font = "24px Arial";
ctx.fillText("Final Score: " + score, canvas.width / 2 - 80, canvas.height / 2 + 40);
  }
}
  // ゲームの再起動ボタンをクリックした際にゲームを再起動する関数
  function restartGame() {
      // ゲームオーバー状態をリセット
      gameOver = false;

      // プレイヤーの初期位置にリセット
      player.x = canvas.width / 2;
      player.y = canvas.height - 30 - 30;

      // 敵の初期化
      enemies = [];
      enemySpawnCounter = 0;
      moveDirection = 1;
      moveDownCounter = 0;
      score = 0;

      // ゲームを再開
      update();
    }
  </script>
</body>
</html>